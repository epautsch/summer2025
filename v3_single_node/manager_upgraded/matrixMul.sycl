#include <CL/sycl.hpp>
#include <iostream>
#include <vector>

using namespace cl::sycl;

int main() {
  const int N = 1024;
  const int M = 1024;
  const int K = 1024;

  std::vector<float> A(N * K);
  std::vector<float> B(K * M);
  std::vector<float> C(N * M);

  // Initialize matrices A and B
  for (int i = 0; i < N * K; ++i) {
    A[i] = static_cast<float>(i % 10);
  }
  for (int i = 0; i < K * M; ++i) {
    B[i] = static_cast<float>(i % 10);
  }

  queue q;
  range<1> range_N(N);
  range<1> range_M(M);
  range<1> range_K(K);

  buffer<float, 2> bufA(A.data(), range_N * range_K);
  buffer<float, 2> bufB(B.data(), range_K * range_M);
  buffer<float, 2> bufC(C.data(), range_N * range_M);

  q.submit([&](handler& cgh) {
    auto accA = bufA.get_access<access::mode::read>(cgh);
    auto accB = bufB.get_access<access::mode::read>(cgh);
    auto accC = bufC.get_access<access::mode::write>(cgh);

    cgh.parallel_for(range_N * range_M, [=](id<2> idx) {
      float sum = 0.0f;
      for (int k = 0; k < K; ++k) {
        sum += accA[idx[0]][k] * accB[k][idx[1]];
      }
      accC[idx[0]][idx[1]] = sum;
    });
  }).wait();

  // Print some elements of the result matrix
  std::cout << "Matrix multiplication completed successfully!" << std::endl;

  return 0;
}
